export default {
  title: "03 Auditoria P2",
  videoId: "WXYLoANPV7o",
  notes: [
    { type: "subtitle", content: "Eventos de dominio que son iguales" },
    { type: "text", content: "Si dos eventos de dominio son iguales, ejemplo: FieldUpdatedDomainEvent y FieldCreatedDomainEvent, ¿cuál sería vuestra aproximación para ser lo más DRY posible y a su vez claro semánticamente?" },
    { type: "text", content: "No tienen por qué ser iguales, normalmente optamos por escenarios:" },
    { type: "text", content: "• El evento de creación lleva todo: FieldCreatedDomainEvent" },
    { type: "text", content: "• Eventos de modificaciones más granular FieldRenamedDomainEvent, FieldDescriptionModifiedDomainEvent" },
    { type: "subtitle", content: "Pros" },
    { type: "text", content: "• Más sencillo reaccionar a lo que nos interesa" },
    { type: "text", content: "• No tenemos que preocuparnos de qué forma añadir qué se ha modificado en el evento de updated (simplifica el código al diff si no ser necesario)" },
    { type: "subtitle", content: "Cons" },
    { type: "text", content: "• Cada vez que quiero modificar mi proyección he de escuchar X eventos" },
    { type: "text", content: "• Más eventos publicados y consumidos (y más coste)" },
    { type: "subtitle", content: "Conclusión" },
    { type: "text", content: "Hay que valorar todas las opciones y cuál de las 2 nos compensa más, pero lo importante es que si publicamos un 'updated', sólo deberían de ir los campos modificados y no necesariamente un snapshot de todo el agregado." },
    { type: "subtitle", content: "Fields que necesitan accounts" },
    { type: "text", content: "Un field, en su creación va asociado a un account (que pertenece a otro módulo). Si estos datos se insertan vía eventos de dominio, me preocupan las latencias. Ya que entre que el cliente crea una cuenta y un campo pueden pasar 3s o 300ms si se hace vía API." },
    { type: "subtitle", content: "Llamando al caso de uso vecino sincrónicamente" },
    { type: "text", content: "El flujo ideal sería (sea desde la web o api):" },
    { type: "text", content: "1. Se crea account." },
    { type: "text", content: "2. Se crea field pasándole el id del account acabado de crear" },
    { type: "text", content: "• Si el cliente ha generado el id él, pasa ese id." },
    { type: "text", content: "• Si el cliente no ha generado el id, pasa el de la respuesta de la llamada anterior." },
    { type: "text", content: "Teniendo en cuenta la modificación que hemos hecho previamente en Field:" },
    { type: "text", content: "• Un Field siempre se va a crear con un Account." },
    { type: "text", content: "• Podríamos aprovechar y añadir esa validación en el Create, que siempre haya como mínimo un accountId" },
    { type: "text", content: "• Por lo pronto desde el contexto queremos validar que el accountId exista." },
    { type: "text", content: "• Parece que están en el mismo BC, en diferentes, podemos preguntarle si existe ese account" },
    { type: "text", content: "• Interesante caso de uso en el mismo BC." },
    { type: "text", content: "• Con un queryBus en diferentes BCs." },
    { type: "subtitle", content: "Utilizando proyecciones" },
    { type: "text", content: "Pero es posible que lo tengamos en BCs diferentes y, por rendimiento, no queramos hacer una petición allí y queramos hacer una proyección de Accounts dentro del mismo BC de Fields." },
    { type: "text", content: "El flujo sería:" },
    { type: "text", content: "1. Se crea un account y se publica el evento de AccountCreated." },
    { type: "text", content: "2. En el mismo contexto donde está Field se crea el módulo Accounts y se hace la proyección." },
    { type: "text", content: "• Este flujo normalmente tarda menos de 50ms en RabbitMQ." },
    { type: "text", content: "• En AWS, depende de cuántas piezas hayan de por medio (EventBridge → SQS), pero de media puede tardar unos 100ms." },
    { type: "text", content: "3. Se crea un Field y se valida que exista. Lo más normal es que ya exista porque el flujo de eventos es muy rápido, pero si no existiera se puede hacer un sleep up to 3 de retries exponenciales." },
    { type: "text", content: "De esta forma solventamos el necesitar comunicarnos por la API Rest cuando necesitamos datos síncronos." },
    { type: "subtitle", content: "Variedad de cultivo custom" },
    { type: "text", content: "En el legacy, cuando se crea una season hay un desplegable para elegir la variedad de cultivo. En el nuevo sistema dejamos que el cliente tenga parámetros custom para añadir sus propios valores. ¿Cómo estandarizar esto?" },
    { type: "subtitle", content: "Rigidez de entrada de datos al datalake" },
    { type: "text", content: "• Si queremos estandarizar el datalake, no podemos tener valores arbitrarios." },
    { type: "text", content: "• Este es un buen caso para utilizar la IA. Definimos unos valores estándares por nuestro lado, y la IA decide cada uno de los parámetros custom en nuestro estándar." },
    { type: "text", content: "De esta manera podemos estandarizar los datos a nuestro estilo, dándole esa flexibilidad al cliente." },
    { type: "text", content: "• Si no queremos añadir IA podemos añadir un campo \"categoría\" o similar cada vez que se crea un nuevo valor para posteriormente utilizar ese dato en el datalake." },
    { type: "subtitle", content: "Traducción en el front" },
    { type: "text", content: "Aquí pasa igual que antes. Si queremos que el valor introducido por el cliente se traduzca a diversos idiomas podemos hacer que el propio cliente añada las posibles traducciones o utilizar IA para generarlas." },
    { type: "subtitle", content: "SQL vs NoSQL" },
    { type: "text", content: "Antes sí que tenías que elegir entre un tipo de base de datos u otro." },
    { type: "text", content: "Hoy en día muchas bases de datos (ejemplo Postgres) tienen soporte de JSON muy bueno." },
    { type: "text", content: "A no ser que sea por tema de performance o costes, para no tener un stack tan diverso, preferiríamos tener solo un tipo de base de datos." },
    { type: "text", content: "En nuestro caso Postgres, ya que nos permite operar de forma SQL y NoSQL." },
    { type: "subtitle", content: "Cambio de esquema en NoSQL" },
    { type: "text", content: "La complejidad añadida viene cuando nos centramos en una modificación de un parámetro donde afecta a configuraciones ya existentes" },
    { type: "text", content: "Tal y como comentáis hay 2 principales formas de hacerlo:" },
    { type: "text", content: "Cada vez que se modifica un parámetro modificar toda la BD" },
    { type: "text", content: "• Se puede hacer en el momento de la modificación o en background." },
    { type: "text", content: "• Se han de recorrer todas las entidades, por lo tanto, aunque depende de la forma puede penalizar mucho, no es muy sano." },
    { type: "text", content: "• Cada vez que se lee una entidad se comprueba si tiene el esquema antiguo y se migra" },
    { type: "text", content: "• Esto puede penalizar el rendimiento de lectura." },
    { type: "text", content: "• Pero es más sano ya que sólo se migra cuando hace falta." },
    { type: "text", content: "• Hay que tener en cuenta que si hay muchas entidades que leer, puede ser un problema." },
    { type: "subtitle", content: "Sobrecarga del módulo access" },
    { type: "text", content: "Cada request que se hace va a pasar por un proceso de autenticación + autorización." },
    { type: "text", content: "Esto puede llegar a sobrecargar ACCESS! ¿Cómo se podría explicar si este enfoque no es bueno?" },
    { type: "text", content: "¿Tendría sentido que toda la policy del usuario estuviera dentro del JWT de autenticación o no? Sería un token bastante largo. Si estuviera dentro no necesitaríamos hacer llamadas al BC de ACCESS cada vez que se quiera validar los permisos de cualquier usuario en cualquier otro BC." },
    { type: "subtitle", content: "Premisa" },
    { type: "text", content: "No somos expertos en algoritmos de autenticación." },
    { type: "text", content: "• En línea hacíamos justamente eso, tokens autofirmados que vía una public/private key los servidores podían verificar los datos." },
    { type: "text", content: "• También se le añadía proof-of-work y proof-of-possession para asegurar la veracidad." },
    { type: "text", content: "• Esto quitó muchísima carga del servicio de autenticación, el cual pasó de recibir muchísimas llamadas a sólo recibir las de regeneración de tokens." },
    { type: "subtitle", content: "Domain Event Subscriber" },
    { type: "text", content: "Caso EntityCreateOnUserCreated" },
    { type: "text", content: "• El SUBSCRIBER_NAME no coincide con el módulo en el que está:" },
    { type: "text", content: "access_user_entity_create_on_user_created VS configuration.entity.entity_create_on_user_created" },
    { type: "text", content: "• El nombre puede ser más explícito: CreateConfigurationEntityOnUserCreated" },
    { type: "text", content: "• Se llama a un entity_use_cases. Se puede crear una clase para cada caso de uso para respetar SRP" },
    { type: "text", content: "• Evitar el uso de dict[str, Any] si podemos optar por tipar los valores." },
    { type: "subtitle", content: "Circuit Breakers y Cachés" },
    { type: "text", content: "¿Dónde y cuándo se deberían implementar?" },
    { type: "subtitle", content: "Circuit Breakers" },
    { type: "text", content: "• Son un parche a cuando no tenemos proyecciones" },
    { type: "text", content: "• El propio Hystrix de Netflix ha sido deprecado" },
    { type: "text", content: "• Recomendación de utilizar Adaptive Concurrency Limits" },
    { type: "text", content: "• Añadirlo en las implementaciones" },
    { type: "subtitle", content: "Cachés" },
    { type: "text", content: "• Añadirla si puede ser como decorador de repositorio" },
    { type: "text", content: "• De esta forma nos contendrá nuestra aplicación y es más sencilla de mantener" },
    { type: "subtitle", content: "Testing" },
    { type: "text", content: "Entendemos que al ser MVP y no estar todas las piezas, sólo hay tests de comportamiento." },
    { type: "text", content: "¿Qué tipología de tests tenéis pensado implementar?" },
    { type: "subtitle", content: "Tests de comportamiento" },
    { type: "text", content: "test_field_creator.py" },
    { type: "subtitle", content: "Naming" },
    { type: "text", content: "• Nombres como test_field_creator_simple no indican qué se está pasando." },
    { type: "text", content: "• Un truco que va muy bien es añadir la keyword should para hacer más explícitos las casuísticas. Por ejemplo:" },
    { type: "text", content: "test_field_creator_should_create_a_valid_field_without_any_account" },
    { type: "subtitle", content: "Casuísticas" },
    { type: "text", content: "• A simple vista parece que sólo estamos cubriendo los happy paths (que se cree con field y sin field), pero no los casos donde puede fallar." },
    { type: "text", content: "• Pero eso no es así. Porque estamos cubriendo más casos, el problema es que:" },
    { type: "subtitle", content: "Lógica dentro de los tests" },
    { type: "text", content: "• Parametrizar los tests es una forma poderosa de poder testear más casuísticas." },
    { type: "text", content: "• Esto lo utilizamos por ejemplo, cuando quieres validar que diversos parámetros de entrada producen diversas salidas." },
    { type: "text", content: "• Si el parametrizar un test hace que tenga que añadir un if de por medio, lo que va a hacer es complicar nuestros tests." },
    { type: "text", content: "• Haciendo que sean más difíciles de leer ya que hay una complejidad ciclomática mayor" },
    { type: "text", content: "• Nos fuerza a hacer un nombre de test más genérico." },
    { type: "text", content: "• Si vemos que estamos introduciendo if dentro de un test, lo mejor es separarlo en 2 y testearlo como 2 casuísticas separadas." }
  ],
};
